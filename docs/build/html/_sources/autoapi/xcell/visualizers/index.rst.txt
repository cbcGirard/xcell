:py:mod:`xcell.visualizers`
===========================

.. py:module:: xcell.visualizers

.. autoapi-nested-parse::

   Visualization routines for meshes.



Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   xcell.visualizers.TimingBar
   xcell.visualizers.DataPrefs
   xcell.visualizers.DisplayPrefs
   xcell.visualizers.SliceViewer
   xcell.visualizers.SortaLogNorm
   xcell.visualizers.FigureAnimator
   xcell.visualizers.SliceSet
   xcell.visualizers.ErrorGraph
   xcell.visualizers.CurrentPlot
   xcell.visualizers.ScaleRange
   xcell.visualizers.SingleSlice
   xcell.visualizers.LogError
   xcell.visualizers.PVScene
   xcell.visualizers.Symlogizer



Functions
~~~~~~~~~

.. autoapisummary::

   xcell.visualizers.engineerTicks
   xcell.visualizers.discreteColors
   xcell.visualizers.discreteLegend
   xcell.visualizers.formatXYAxis
   xcell.visualizers.undrawAxis
   xcell.visualizers.plotBoundEffect
   xcell.visualizers.groupedScatter
   xcell.visualizers.importRunset
   xcell.visualizers.plotStudyPerformance
   xcell.visualizers.errorCompositePlot
   xcell.visualizers.importAndPlotTimes
   xcell.visualizers.stackedTimePlot
   xcell.visualizers.outsideLegend
   xcell.visualizers.showEdges
   xcell.visualizers.showNodes3d
   xcell.visualizers.getCmap
   xcell.visualizers.new3dPlot
   xcell.visualizers.animatedTitle
   xcell.visualizers.equalizeScale
   xcell.visualizers.showRawSlice
   xcell.visualizers.resamplePlane
   xcell.visualizers.showCurrentVecs
   xcell.visualizers.showEdges2d
   xcell.visualizers.pairedBar
   xcell.visualizers.showSourceBoundary
   xcell.visualizers.addInset
   xcell.visualizers.patchworkImage
   xcell.visualizers.showMesh
   xcell.visualizers.getPlanarEdgePoints
   xcell.visualizers.toEdgePoints
   xcell.visualizers.hideBorders
   xcell.visualizers.makeSoloColorbar



Attributes
~~~~~~~~~~

.. autoapisummary::

   xcell.visualizers.MAX_LOG_SPAN


.. py:data:: MAX_LOG_SPAN
   :value: 2

   

.. py:function:: engineerTicks(axis, xunit=None, yunit=None)


.. py:class:: TimingBar(figure, axis, data=None)

   .. py:method:: getArt(time, step=None)



.. py:class:: DataPrefs(name, dataSource=None, scaleStyle=None, cmap=None, norm=None, colors=None)

   .. py:method:: updateRange(newVals)


   .. py:method:: applyPrefs(axis, data)



.. py:class:: DisplayPrefs(nodePrefs=None, edgePrefs=None, imgPrefs=None)


.. py:class:: SliceViewer(axis, sim, displayPrefs=None, topoType='mesh')

   .. py:method:: changeData(newSim)


   .. py:method:: setPlane(normalAxis=2, normCoord=0, showAll=False)


   .. py:method:: movePlane(stepAmount)


   .. py:method:: __setmask(showAll=False)


   .. py:method:: showEdges(connAngle=None, colors=None, **kwargs)


   .. py:method:: showNodes(nodeVals, colors=None, **kwargs)


   .. py:method:: __drawSet()


   .. py:method:: onKey(event)



.. py:function:: discreteColors(values, legendStem='n=')

   Generate colors for discrete (categorical) data.

   :param values: Non-unique values to be color-coded.
   :type values: array of numeric
   :param legendStem: Text preceding category values in legend. The default is 'n='.
   :type legendStem: string, optional

   :returns: * **valColors** (*2d array*) -- Colors assigned to each input value.
             * **legEntries** (*list of matplotlib Patch*) -- Dummy objects to generate color legend
               [with legend(handles=legEntry)].


.. py:function:: discreteLegend(axis, data, legendStem='n=', **kwargs)

   Color-code data and generate corresponding legend.

   :param axis: Axes to place legend in.
   :type axis: matplotlib Axes
   :param data: Data to be color-coded.
   :type data: numeric
   :param legendStem: Legend text preceding values. The default is 'n='.
   :type legendStem: string, optional

   :returns: **colors** -- Color corresponding to value of each data point.
   :rtype: array of colors


.. py:class:: SortaLogNorm(linthresh, linscale=0.1, vmin=None, vmax=None, clip=False)

   Bases: :py:obj:`matplotlib.colors.SymLogNorm`

   The symmetrical logarithmic scale is logarithmic in both the
   positive and negative directions from the origin.

   Since the values close to zero tend toward infinity, there is a
   need to have a range around zero that is linear.  The parameter
   *linthresh* allows the user to specify the size of this range
   (-*linthresh*, *linthresh*).

   :param linthresh: The range within which the plot is linear (to avoid having the plot
                     go to infinity around zero).
   :type linthresh: float
   :param linscale: This allows the linear range (-*linthresh* to *linthresh*) to be
                    stretched relative to the logarithmic range. Its value is the
                    number of decades to use for each half of the linear range. For
                    example, when *linscale* == 1.0 (the default), the space used for
                    the positive and negative halves of the linear range will be equal
                    to one decade in the logarithmic range.
   :type linscale: float, default: 1
   :param base:
   :type base: float, default: 10

   .. py:method:: __call__(value, clip=None)

      Normalize *value* data in the ``[vmin, vmax]`` interval into the
      ``[0.0, 1.0]`` interval and return it.

      :param value: Data to normalize.
      :param clip: If ``None``, defaults to ``self.clip`` (which defaults to
                   ``False``).
      :type clip: bool

      .. rubric:: Notes

      If not already initialized, ``self.vmin`` and ``self.vmax`` are
      initialized using ``self.autoscale_None(value)``.


   .. py:method:: inverse(value)



.. py:function:: formatXYAxis(axis, bounds=None, symlog=False, lindist=None, axlabels=False, xlabel='X [m]', ylabel='Y [m]')

   Set up axis for planar slices of 3d space.

   :param axis: Axes to format.
   :type axis: matplotlib Axes
   :param bounds: Explicit limits for axes, [xmin, xmax, ymin, ymax]. The default is None.
   :type bounds: TYPE, optional
   :param symlog: Use symmetric log scales, or linear if None. The default is None.
   :type symlog: bool, optional
   :param lindist: Forces linear scale on (-lindist, lindist)
   :type lindist: float, optional
   :param xlabel: Horizontal axis label. The default is 'X [m]'.
   :type xlabel: string, optional
   :param ylabel: Vertical axis label. The default is 'Y [m]'.
   :type ylabel: string, optional

   :rtype: None.


.. py:function:: undrawAxis(axis)

   Remove contents from axis, preserving scale/labels/ticks.

   :param axis: Axes to clear.
   :type axis: matplotlib Axes

   :rtype: None.


.. py:function:: plotBoundEffect(fname, ycat='FVU', xcat='Domain size', groupby='Number of elements', legstem='%d elements')


.. py:function:: groupedScatter(fname, xcat, ycat, groupcat, filtercat=None, df=None, ax=None, **kwargs)


.. py:function:: importRunset(fname)


.. py:function:: plotStudyPerformance(study, **kwargs)


.. py:function:: errorCompositePlot(data, sortCat, labels=None)


.. py:function:: importAndPlotTimes(fname, timeType='Wall', ax=None, onlyCat=None, onlyVal=None, xCat='Number of elements', **kwargs)


.. py:function:: stackedTimePlot(axis, xvals, stepTimes, stepNames, **kwargs)


.. py:function:: outsideLegend(axis=None, flipOrder=False, where='right', **kwargs)

   Create legend outside of axes, at top right.

   :param axis: DESCRIPTION. The default is None.
   :type axis: matplotlib Axes, optional
   :param \*\*kwargs: Parameters passed to legend().
   :type \*\*kwargs: TYPE

   :rtype: None.


.. py:function:: showEdges(axis, coords, edgeIndices, edgeVals=None, colorbar=True, **kwargs)


.. py:function:: showNodes3d(axis, coords, nodeVals, cMap=None, cNorm=None, colors=None, **kwargs)

   Show mesh nodes in 3d.

   :param axis: Axes to plot on.
   :type axis: maplotlib Axes
   :param coords: DESCRIPTION.
   :type coords: array of cartesian coordinates
   :param nodeVals: Values to set node coloring.
   :type nodeVals: numeric array
   :param cMap: DESCRIPTION. The default is None.
   :type cMap: colormap, optional
   :param cNorm: DESCRIPTION. The default is None.
   :type cNorm: matplotlib Norm, optional
   :param colors: DESCRIPTION. The default is None.
   :type colors: TYPE, optional

   :returns: **scatterArt** -- DESCRIPTION.
   :rtype: TYPE


.. py:function:: getCmap(vals, forceBipolar=False, logscale=False)

   Get appropriate colormap for given continuous data.

   By default, uses plasma if data is mostly all positive
   or negative; otherwise, seismic is used and scaled around
   zero.

   Linear scaling will be used unless logscale=True, in
   which case log/symlog is automatically

   :param vals: Data to be colored.
   :type vals: numeric
   :param forceBipolar: DESCRIPTION. The default is False.
   :type forceBipolar: bool, optional
   :param logscale: DESCRIPTION. The default is False.
   :type logscale: bool, optional

   :returns: * **cMap** (*colormap*) -- Selected colormap.
             * **cNorm** (*matplotlib Norm*) -- Norm function to map data to (0,1) range of colormap.


.. py:function:: new3dPlot(boundingBox=None, *args, fig=None)

   Force 3d axes to same scale
   Based on https://stackoverflow.com/a/13701747


.. py:function:: animatedTitle(figure, text, axis=None)


.. py:function:: equalizeScale(ax)

   Force 3d axes to same scale.

   Method based on https://stackoverflow.com/a/13701747

   :param axis:
   :type axis: matplotlib Axes

   :rtype: None.


.. py:function:: showRawSlice(valList, ndiv)


.. py:function:: resamplePlane(axis, sim, movetoCenter=True, elements=None, data=None)

   :param axis: DESCRIPTION.
   :type axis: TYPE
   :param sim: DESCRIPTION.
   :type sim: TYPE

   :returns: DESCRIPTION.
   :rtype: TYPE


.. py:function:: showCurrentVecs(axis, pts, vecs)

   Plot current vectors in 3d.

   :param axis: Axis to plot on.
   :type axis: axis
   :param pts: Coordinates of vector tails.
   :type pts: float[:,3]
   :param vecs: Current density vectors.
   :type vecs: float[:,3]

   :returns: **art** -- DESCRIPTION.
   :rtype: Quiver


.. py:function:: showEdges2d(axis, edgePoints, edgeColors=None, **kwargs)

   Show mesh edges in a 2d plot.

   :param axis: 2d axis to plot in.
   :type axis: matplotlib axis
   :param edgePoints: .
   :type edgePoints: List of pairs of xy coords
   :param edgeColors: DESCRIPTION. The default is None.
   :type edgeColors: float[:], optional
   :param \*\*kwargs: Args passed to matplotlib LineCollection.
   :type \*\*kwargs: TYPE

   :returns: **edgeCol** -- Artist for displaying the edges.
   :rtype: matplotlib LineCollection


.. py:function:: pairedBar(data1, data2, labels, categories=None, axis=None, aright=None)

   Plot paired bars.

   :param data1: First list of data points
   :type data1: float[:]
   :param data2: Other data set
   :type data2: float[:]
   :param labels: Legend labels for the two data sets
   :type labels: str[:]
   :param categories: X-axis labels, or simply numbered if None (default)
   :type categories: str[:], optional
   :param axis: Axes to plot on, or current if None
   :type axis: Axis
   :param aright: Paired axis for plotting data2 on right-hand scale.
   :type aright: Axis


.. py:function:: showSourceBoundary(axes, radius, srcCenter=np.zeros(2))

   Plot faint ring representing source's boundary.

   :param axes: Axes to plot to
   :type axes: [axis]
   :param radius: Source radius.
   :type radius: float
   :param srcCenter: Center of source. The default is np.zeros(2).
   :type srcCenter: float[:], optional

   :rtype: None.


.. py:function:: addInset(baseAxis, rInset, xmax, relativeLoc=(0.5, -0.65))

   Create sub-axis for plotting a zoomed-in view of the main axis.

   Plot commands executed in the main axis DO NOT automatically appear
   in inset; to keep them synchronized, use a pattern like

   axes=[mainAx,inset]
   for ax in axes:
       ax.plot_command(...)

   :param baseAxis: Parent axis.
   :type baseAxis: axis
   :param rInset:
                  Size of inset bounds (such that bounding box is
                                        rInset*[-1,1,-1,1])
   :type rInset: float
   :param xmax: Size of parent axis' bounds.
   :type xmax: float
   :param relativeLoc: Placement of inset's center, relative to parent axis.
                       The default is (.5, -.8), which plots
                       directly beneath the main plot.
   :type relativeLoc: TYPE, optional

   :returns: **inset** -- Inset axis.
   :rtype: axis


.. py:function:: patchworkImage(axis, maskedArrays, cMap, cNorm, extent)

   Produce composite image from discrete rectangular regions.

   Shows the actual interpolation structure of adaptive (non-conforming)
   grid

   :param axis: Axis to plot on.
   :type axis: axis
   :param quadBbox: List of [xmin, xmax, ymin, ymax] for each discrete
                    rectangle.
   :type quadBbox: float[:,:]
   :param quadVal: DESCRIPTION.
   :type quadVal: float[:,:]
   :param cMap: Desired colormap for image.
   :type cMap: colormap
   :param cNorm: Desired colormap.
   :type cNorm: norm

   :returns: **imlist** -- Artists required to tile region.
   :rtype: list of artists


.. py:function:: showMesh(setup, axis=None)


.. py:function:: getPlanarEdgePoints(coords, edges, normalAxis=2, axisCoord=0)


.. py:function:: toEdgePoints(planeCoords, edges)


.. py:class:: FigureAnimator(fig, study, prefs=None)

   .. py:method:: __getstate__()


   .. py:method:: __setstate__(state)


   .. py:method:: setupFigure()


   .. py:method:: addSimulationData(sim, append=False)


   .. py:method:: animateStudy(fname=None, artists=None, extraArtists=None, fps=1.0, vectorFrames=[])


   .. py:method:: getStudyData(**kwargs)


   .. py:method:: getArtists(setnumber=None, data=None)


   .. py:method:: resetFigure()


   .. py:method:: unifyScales(otherScales)


   .. py:method:: toLiteMode()


   .. py:method:: copy(newFigure=None, overridePrefs={})


   .. py:method:: getSnapshots(frameNos, name)



.. py:class:: SliceSet(fig, study, prefs=None)

   Bases: :py:obj:`FigureAnimator`

   .. py:method:: __getstate__()


   .. py:method:: setupFigure(resetBounds=False)


   .. py:method:: addSimulationData(sim, append=False)


   .. py:method:: getArtists(setnum, data=None)



.. py:class:: ErrorGraph(fig, study, prefs=None)

   Bases: :py:obj:`FigureAnimator`

   .. py:method:: setupFigure(labelX=True, labelY=True, newAxes=True)


   .. py:method:: addSimulationData(sim, append=False)


   .. py:method:: getArtists(setnum, data=None)



.. py:class:: CurrentPlot(fig, study, fullarrow=False, showInset=True, showAll=False, normalAxis=2, normalCoord=0.0)

   Bases: :py:obj:`FigureAnimator`

   .. py:method:: addSimulationData(sim, append=False)


   .. py:method:: getArtists(setnum)



.. py:class:: ScaleRange(vals=None)

   .. py:method:: update(newVals)


   .. py:method:: get(forceBipolar=False, forceSymmetric=False)



.. py:function:: hideBorders(axis, hidex=False)


.. py:class:: SingleSlice(fig, study, timevec=[], tdata=None, datasrc='spaceV', prefs=None)

   Bases: :py:obj:`FigureAnimator`

   .. py:method:: copy(newPrefs=None)


   .. py:method:: setupFigure()


   .. py:method:: getArtists(setnum, data=None)


   .. py:method:: addSimulationData(sim, append=False)


   .. py:method:: animateStudy(fname=None, artists=None, fps=30.0, vectorFrames=[], unitStr=None)


   .. py:method:: solobar(fname, unit=None)



.. py:function:: makeSoloColorbar(data, cmap=None, norm=None, unit=None, **kwargs)


.. py:class:: LogError(fig, study, prefs=None)

   Bases: :py:obj:`FigureAnimator`

   .. py:method:: addSimulationData(sim, append=False)


   .. py:method:: getArtists(setnum, data=None)



.. py:class:: PVScene(study=None, time=None, **kwargs)

   Bases: :py:obj:`pyvista.Plotter`

   Plotting object to display vtk meshes or numpy arrays.

   :param off_screen: Renders off screen when ``True``.  Useful for automated
                      screenshots.
   :type off_screen: bool, optional
   :param notebook: When ``True``, the resulting plot is placed inline a jupyter
                    notebook.  Assumes a jupyter console is active.  Automatically
                    enables ``off_screen``.
   :type notebook: bool, optional
   :param shape: Number of sub-render windows inside of the main window.
                 Specify two across with ``shape=(2, 1)`` and a two by two grid
                 with ``shape=(2, 2)``.  By default there is only one render
                 window.  Can also accept a string descriptor as shape. E.g.:

                 * ``shape="3|1"`` means 3 plots on the left and 1 on the right,
                 * ``shape="4/2"`` means 4 plots on top and 2 at the bottom.
   :type shape: sequence[int], optional
   :param border: Draw a border around each render window.
   :type border: bool, optional
   :param border_color:
                        Either a string, rgb list, or hex color string.  For example:

                            * ``color='white'``
                            * ``color='w'``
                            * ``color=[1.0, 1.0, 1.0]``
                            * ``color='#FFFFFF'``
   :type border_color: ColorLike, default: "k"
   :param window_size: Window size in pixels.  Defaults to ``[1024, 768]``, unless
                       set differently in the relevant theme's ``window_size``
                       property.
   :type window_size: sequence[int], optional
   :param multi_samples: The number of multi-samples used to mitigate aliasing. 4 is a
                         good default but 8 will have better results with a potential
                         impact on performance.
   :type multi_samples: int, optional
   :param line_smoothing: If ``True``, enable line smoothing.
   :type line_smoothing: bool, default: False
   :param polygon_smoothing: If ``True``, enable polygon smoothing.
   :type polygon_smoothing: bool, default: False
   :param lighting: Lighting to set up for the plotter. Accepted options:

                    * ``'light kit'``: a vtk Light Kit composed of 5 lights.
                    * ``'three lights'``: illumination using 3 lights.
                    * ``'none'``: no light sources at instantiation.

                    The default is a ``'light kit'`` (to be precise, 5 separate
                    lights that act like a Light Kit).
   :type lighting: str, default: 'light kit"
   :param theme: Plot-specific theme.
   :type theme: pyvista.themes.DefaultTheme, optional
   :param image_scale: Scale factor when saving screenshots. Image sizes will be
                       the ``window_size`` multiplied by this scale factor.
   :type image_scale: int, optional

   .. rubric:: Examples

   >>> import pyvista as pv
   >>> mesh = pv.Cube()
   >>> another_mesh = pv.Sphere()
   >>> pl = pv.Plotter()
   >>> actor = pl.add_mesh(
   ...     mesh, color='red', style='wireframe', line_width=4
   ... )
   >>> actor = pl.add_mesh(another_mesh, color='blue')
   >>> pl.show()

   .. py:method:: setTime(time)


   .. py:method:: setup(regions, mesh=None, simData=None, **meshkwargs)


   .. py:method:: planeview(planeBox, scale=1.0, normal='z')


   .. py:method:: clear()

      Clear plot by removing all actors and properties.

      .. rubric:: Examples

      >>> import pyvista
      >>> plotter = pyvista.Plotter()
      >>> actor = plotter.add_mesh(pyvista.Sphere())
      >>> plotter.clear()
      >>> plotter.renderer.actors
      {}


   .. py:method:: close(**kwargs)

      Close the render window.

      :param render: Unused argument.
      :type render: bool


   .. py:method:: add_symlog(mesh, data=None, **kwargs)


   .. py:method:: show_edges(mesh)


   .. py:method:: add_mesh(mesh, **kwargs)

      Add any PyVista/VTK mesh or dataset that PyVista can wrap to the scene.

      This method is using a mesh representation to view the surfaces
      and/or geometry of datasets. For volume rendering, see
      :func:`pyvista.Plotter.add_volume`.

      To see the what most of the following parameters look like in action,
      please refer to :class:`pyvista.Property`.

      :param mesh: Any PyVista or VTK mesh is supported. Also, any dataset
                   that :func:`pyvista.wrap` can handle including NumPy
                   arrays of XYZ points. Plotting also supports VTK algorithm
                   objects (``vtk.vtkAlgorithm`` and ``vtk.vtkAlgorithmOutput``).
                   When passing an algorithm, the rendering pipeline will be
                   connected to the passed algorithm to dynamically update
                   the scene.
      :type mesh: pyvista.DataSet or pyvista.MultiBlock or vtk.vtkAlgorithm
      :param color: Use to make the entire mesh have a single solid color.
                    Either a string, RGB list, or hex color string.  For example:
                    ``color='white'``, ``color='w'``, ``color=[1.0, 1.0, 1.0]``, or
                    ``color='#FFFFFF'``. Color will be overridden if scalars are
                    specified.

                    Defaults to :attr:`pyvista.global_theme.color
                    <pyvista.themes.DefaultTheme.color>`.
      :type color: ColorLike, optional
      :param style: Visualization style of the mesh.  One of the following:
                    ``style='surface'``, ``style='wireframe'``, ``style='points'``,
                    ``style='points_gaussian'``. Defaults to ``'surface'``. Note that
                    ``'wireframe'`` only shows a wireframe of the outer geometry.
                    ``'points_gaussian'`` can be modified with the ``emissive``,
                    ``render_points_as_spheres`` options.
      :type style: str, optional
      :param scalars: Scalars used to "color" the mesh.  Accepts a string name
                      of an array that is present on the mesh or an array equal
                      to the number of cells or the number of points in the
                      mesh.  Array should be sized as a single vector. If both
                      ``color`` and ``scalars`` are ``None``, then the active
                      scalars are used.
      :type scalars: str | numpy.ndarray, optional
      :param clim: Two item color bar range for scalars.  Defaults to minimum and
                   maximum of scalars array.  Example: ``[-1, 2]``. ``rng`` is
                   also an accepted alias for this.
      :type clim: sequence[float], optional
      :param show_edges: Shows the edges of a mesh.  Does not apply to a wireframe
                         representation.
      :type show_edges: bool, optional
      :param edge_color: The solid color to give the edges when ``show_edges=True``.
                         Either a string, RGB list, or hex color string.

                         Defaults to :attr:`pyvista.global_theme.edge_color
                         <pyvista.themes.DefaultTheme.edge_color>`.
      :type edge_color: ColorLike, optional
      :param point_size: Point size of any nodes in the dataset plotted. Also
                         applicable when style='points'. Default ``5.0``.
      :type point_size: float, optional
      :param line_width: Thickness of lines.  Only valid for wireframe and surface
                         representations.  Default ``None``.
      :type line_width: float, optional
      :param opacity: Opacity of the mesh. If a single float value is given, it
                      will be the global opacity of the mesh and uniformly
                      applied everywhere - should be between 0 and 1. A string
                      can also be specified to map the scalars range to a
                      predefined opacity transfer function (options include:
                      ``'linear'``, ``'linear_r'``, ``'geom'``, ``'geom_r'``).
                      A string could also be used to map a scalars array from
                      the mesh to the opacity (must have same number of elements
                      as the ``scalars`` argument). Or you can pass a custom
                      made transfer function that is an array either
                      ``n_colors`` in length or shorter.
      :type opacity: float | str| array_like
      :param flip_scalars: Flip direction of cmap. Most colormaps allow ``*_r``
                           suffix to do this as well.
      :type flip_scalars: bool, default: False
      :param lighting: Enable or disable view direction lighting. Default ``False``.
      :type lighting: bool, optional
      :param n_colors: Number of colors to use when displaying scalars. Defaults to 256.
                       The scalar bar will also have this many colors.
      :type n_colors: int, optional
      :param interpolate_before_map: Enabling makes for a smoother scalars display.  Default is
                                     ``True``.  When ``False``, OpenGL will interpolate the
                                     mapped colors which can result is showing colors that are
                                     not present in the color map.
      :type interpolate_before_map: bool, optional
      :param cmap: If a string, this is the name of the ``matplotlib`` colormap to use
                   when mapping the ``scalars``.  See available Matplotlib colormaps.
                   Only applicable for when displaying ``scalars``.
                   ``colormap`` is also an accepted alias
                   for this. If ``colorcet`` or ``cmocean`` are installed, their
                   colormaps can be specified by name.

                   You can also specify a list of colors to override an existing
                   colormap with a custom one.  For example, to create a three color
                   colormap you might specify ``['green', 'red', 'blue']``.

                   This parameter also accepts a :class:`pyvista.LookupTable`. If this
                   is set, all parameters controlling the color map like ``n_colors``
                   will be ignored.
      :type cmap: str | list | pyvista.LookupTable, default: :attr:`pyvista.themes.DefaultTheme.cmap`
      :param label: String label to use when adding a legend to the scene with
                    :func:`pyvista.Plotter.add_legend`.
      :type label: str, optional
      :param reset_camera: Reset the camera after adding this mesh to the scene. The default
                           setting is ``None``, where the camera is only reset if this plotter
                           has already been shown. If ``False``, the camera is not reset
                           regardless of the state of the ``Plotter``. When ``True``, the
                           camera is always reset.
      :type reset_camera: bool, optional
      :param scalar_bar_args: Dictionary of keyword arguments to pass when adding the
                              scalar bar to the scene. For options, see
                              :func:`pyvista.Plotter.add_scalar_bar`.
      :type scalar_bar_args: dict, optional
      :param show_scalar_bar: If ``False``, a scalar bar will not be added to the
                              scene.
      :type show_scalar_bar: bool, optional
      :param multi_colors: If a :class:`pyvista.MultiBlock` dataset is given this will color
                           each block by a solid color using matplotlib's color cycler.
      :type multi_colors: bool, default: False
      :param name: The name for the added mesh/actor so that it can be easily
                   updated.  If an actor of this name already exists in the
                   rendering window, it will be replaced by the new actor.
      :type name: str, optional
      :param texture: A texture to apply if the input mesh has texture
                      coordinates.  This will not work with MultiBlock
                      datasets. If set to ``True``, the first available texture
                      on the object will be used. If a string name is given, it
                      will pull a texture with that name associated to the input
                      mesh.
      :type texture: vtk.vtkTexture or np.ndarray or bool or str, optional
      :param render_points_as_spheres: Render points as spheres rather than dots.
      :type render_points_as_spheres: bool, optional
      :param render_lines_as_tubes: Show lines as thick tubes rather than flat lines.  Control
                                    the width with ``line_width``.
      :type render_lines_as_tubes: bool, optional
      :param smooth_shading: Enable smooth shading when ``True`` using the Phong
                             shading algorithm.  When ``False``, use flat shading.
                             Automatically enabled when ``pbr=True``.  See
                             :ref:`shading_example`.
      :type smooth_shading: bool, optional
      :param split_sharp_edges: Split sharp edges exceeding 30 degrees when plotting with smooth
                                shading.  Control the angle with the optional keyword argument
                                ``feature_angle``.  By default this is ``False`` unless overridden
                                by the global or plotter theme.  Note that enabling this will
                                create a copy of the input mesh within the plotter.  See
                                :ref:`shading_example`.
      :type split_sharp_edges: bool, optional
      :param ambient: When lighting is enabled, this is the amount of light in
                      the range of 0 to 1 (default 0.0) that reaches the actor
                      when not directed at the light source emitted from the
                      viewer.
      :type ambient: float, optional
      :param diffuse: The diffuse lighting coefficient. Default 1.0.
      :type diffuse: float, optional
      :param specular: The specular lighting coefficient. Default 0.0.
      :type specular: float, optional
      :param specular_power: The specular power. Between 0.0 and 128.0.
      :type specular_power: float, optional
      :param nan_color: The color to use for all ``NaN`` values in the plotted
                        scalar array.
      :type nan_color: ColorLike, optional
      :param nan_opacity: Opacity of ``NaN`` values.  Should be between 0 and 1.
                          Default 1.0.
      :type nan_opacity: float, optional
      :param culling: Does not render faces that are culled. Options are
                      ``'front'`` or ``'back'``. This can be helpful for dense
                      surface meshes, especially when edges are visible, but can
                      cause flat meshes to be partially displayed.  Defaults to
                      ``False``.
      :type culling: str, optional
      :param rgb: If an 2 dimensional array is passed as the scalars, plot
                  those values as RGB(A) colors. ``rgba`` is also an
                  accepted alias for this.  Opacity (the A) is optional.  If
                  a scalars array ending with ``"_rgba"`` is passed, the default
                  becomes ``True``.  This can be overridden by setting this
                  parameter to ``False``.
      :type rgb: bool, optional
      :param categories: If set to ``True``, then the number of unique values in
                         the scalar array will be used as the ``n_colors``
                         argument.
      :type categories: bool, optional
      :param silhouette: If set to ``True``, plot a silhouette highlight for the
                         mesh. This feature is only available for a triangulated
                         ``PolyData``.  As a ``dict``, it contains the properties
                         of the silhouette to display:

                             * ``color``: ``ColorLike``, color of the silhouette
                             * ``line_width``: ``float``, edge width
                             * ``opacity``: ``float`` between 0 and 1, edge transparency
                             * ``feature_angle``: If a ``float``, display sharp edges
                               exceeding that angle in degrees.
                             * ``decimate``: ``float`` between 0 and 1, level of decimation
      :type silhouette: dict, bool, optional
      :param use_transparency: Invert the opacity mappings and make the values correspond
                               to transparency.
      :type use_transparency: bool, optional
      :param below_color: Solid color for values below the scalars range
                          (``clim``). This will automatically set the scalar bar
                          ``below_label`` to ``'below'``.
      :type below_color: ColorLike, optional
      :param above_color: Solid color for values below the scalars range
                          (``clim``). This will automatically set the scalar bar
                          ``above_label`` to ``'above'``.
      :type above_color: ColorLike, optional
      :param annotations: Pass a dictionary of annotations. Keys are the float
                          values in the scalars range to annotate on the scalar bar
                          and the values are the string annotations.
      :type annotations: dict, optional
      :param pickable: Set whether this actor is pickable.
      :type pickable: bool, optional
      :param preference: When ``mesh.n_points == mesh.n_cells`` and setting
                         scalars, this parameter sets how the scalars will be
                         mapped to the mesh.  Default ``'point'``, causes the
                         scalars will be associated with the mesh points.  Can be
                         either ``'point'`` or ``'cell'``.
      :type preference: str, default: "point"
      :param log_scale: Use log scale when mapping data to colors. Scalars less
                        than zero are mapped to the smallest representable
                        positive float.
      :type log_scale: bool, default: False
      :param pbr: Enable physics based rendering (PBR) if the mesh is
                  ``PolyData``.  Use the ``color`` argument to set the base
                  color.
      :type pbr: bool, optional
      :param metallic: Usually this value is either 0 or 1 for a real material
                       but any value in between is valid. This parameter is only
                       used by PBR interpolation.
      :type metallic: float, optional
      :param roughness: This value has to be between 0 (glossy) and 1 (rough). A
                        glossy material has reflections and a high specular
                        part. This parameter is only used by PBR
                        interpolation.
      :type roughness: float, optional
      :param render: Force a render when ``True``.
      :type render: bool, default: True
      :param component: Set component of vector valued scalars to plot.  Must be
                        nonnegative, if supplied. If ``None``, the magnitude of
                        the vector is plotted.
      :type component: int, optional
      :param emissive: Treat the points/splats as emissive light sources. Only valid for
                       ``style='points_gaussian'`` representation.
      :type emissive: bool, optional
      :param copy_mesh: If ``True``, a copy of the mesh will be made before adding it to
                        the plotter.  This is useful if you would like to add the same
                        mesh to a plotter multiple times and display different
                        scalars. Setting ``copy_mesh`` to ``False`` is necessary if you
                        would like to update the mesh after adding it to the plotter and
                        have these updates rendered, e.g. by changing the active scalars or
                        through an interactive widget. This should only be set to ``True``
                        with caution. Defaults to ``False``. This is ignored if the input
                        is a ``vtkAlgorithm`` subclass.
      :type copy_mesh: bool, default: False
      :param backface_params: A :class:`pyvista.Property` or a dict of parameters to use for
                              backface rendering. This is useful for instance when the inside of
                              oriented surfaces has a different color than the outside. When a
                              :class:`pyvista.Property`, this is directly used for backface
                              rendering. When a dict, valid keys are :class:`pyvista.Property`
                              attributes, and values are corresponding values to use for the
                              given property. Omitted keys (or the default of
                              ``backface_params=None``) default to the corresponding frontface
                              properties.
      :type backface_params: dict | pyvista.Property, optional
      :param show_vertices: When ``style`` is not ``'points'``, render the external surface
                            vertices. The following optional keyword arguments may be used to
                            control the style of the vertices:

                            * ``vertex_color`` - The color of the vertices
                            * ``vertex_style`` - Change style to ``'points_gaussian'``
                            * ``vertex_opacity`` - Control the opacity of the vertices
      :type show_vertices: bool, optional
      :param \*\*kwargs: Optional keyword arguments.
      :type \*\*kwargs: dict, optional

      :returns: Actor of the mesh.
      :rtype: pyvista.plotting.actor.Actor

      .. rubric:: Examples

      Add a sphere to the plotter and show it with a custom scalar
      bar title.

      >>> import pyvista as pv
      >>> sphere = pv.Sphere()
      >>> sphere['Data'] = sphere.points[:, 2]
      >>> plotter = pv.Plotter()
      >>> _ = plotter.add_mesh(
      ...     sphere, scalar_bar_args={'title': 'Z Position'}
      ... )
      >>> plotter.show()

      Plot using RGB on a single cell.  Note that since the number of
      points and the number of cells are identical, we have to pass
      ``preference='cell'``.

      >>> import pyvista as pv
      >>> import numpy as np
      >>> vertices = np.array(
      ...     [
      ...         [0, 0, 0],
      ...         [1, 0, 0],
      ...         [0.5, 0.667, 0],
      ...         [0.5, 0.33, 0.667],
      ...     ]
      ... )
      >>> faces = np.hstack(
      ...     [[3, 0, 1, 2], [3, 0, 3, 2], [3, 0, 1, 3], [3, 1, 2, 3]]
      ... )
      >>> mesh = pv.PolyData(vertices, faces)
      >>> mesh.cell_data['colors'] = [
      ...     [255, 255, 255],
      ...     [0, 255, 0],
      ...     [0, 0, 255],
      ...     [255, 0, 0],
      ... ]
      >>> plotter = pv.Plotter()
      >>> _ = plotter.add_mesh(
      ...     mesh,
      ...     scalars='colors',
      ...     lighting=False,
      ...     rgb=True,
      ...     preference='cell',
      ... )
      >>> plotter.camera_position = 'xy'
      >>> plotter.show()

      Note how this varies from ``preference=='point'``.  This is
      because each point is now being individually colored, versus
      in ``preference=='point'``, each cell face is individually
      colored.

      >>> plotter = pv.Plotter()
      >>> _ = plotter.add_mesh(
      ...     mesh,
      ...     scalars='colors',
      ...     lighting=False,
      ...     rgb=True,
      ...     preference='point',
      ... )
      >>> plotter.camera_position = 'xy'
      >>> plotter.show()

      Plot a plane with a constant color and vary its opacity by point.

      >>> plane = pv.Plane()
      >>> plane.plot(
      ...     color='b',
      ...     opacity=np.linspace(0, 1, plane.n_points),
      ...     show_edges=True,
      ... )

      Plot the points of a sphere with Gaussian smoothing while coloring by z
      position.

      >>> mesh = pv.Sphere()
      >>> mesh.plot(
      ...     scalars=mesh.points[:, 2],
      ...     style='points_gaussian',
      ...     opacity=0.5,
      ...     point_size=10,
      ...     render_points_as_spheres=False,
      ...     show_scalar_bar=False,
      ... )


   .. py:method:: save_graphic(filename, **kwargs)

      Save a screenshot of the rendering window as a graphic file.

      This can be helpful for publication documents.

      The supported formats are:

      * ``'.svg'``
      * ``'.eps'``
      * ``'.ps'``
      * ``'.pdf'``
      * ``'.tex'``

      :param filename: Path to fsave the graphic file to.
      :type filename: str
      :param title: Title to use within the file properties.
      :type title: str, default: "PyVista Export"
      :param raster: Attempt to write 3D properties as a raster image.
      :type raster: bool, default: True
      :param painter: Configure the exporter to expect a painter-ordered 2D
                      rendering, that is, a rendering at a fixed depth where
                      primitives are drawn from the bottom up.
      :type painter: bool, default: True

      .. rubric:: Examples

      >>> import pyvista
      >>> from pyvista import examples
      >>> pl = pyvista.Plotter()
      >>> _ = pl.add_mesh(examples.load_airplane(), smooth_shading=True)
      >>> _ = pl.add_background_image(examples.mapfile)
      >>> pl.save_graphic("img.svg")  # doctest:+SKIP



.. py:class:: Symlogizer(valRange, linrange=0.1)

   .. py:method:: change_data(newData)



